<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>λ Cosme Zamudio</title>
    <link>/</link>
    <description>Recent content on λ Cosme Zamudio</description>
    <generator>Hugo</generator>
    <language>es-MX</language>
    <lastBuildDate>Mon, 23 Sep 2024 22:25:38 -0700</lastBuildDate>
    <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>El Stack</title>
      <link>/blog/stack/</link>
      <pubDate>Mon, 23 Sep 2024 22:25:38 -0700</pubDate>
      <guid>/blog/stack/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;Este artículo surgió gracias a mis experimentos con &lt;a href=&#34;https://github.com/cosmez/stack_machine&#34;&gt;stack machines&lt;/a&gt; en C#.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;Mejorar el rendimiento y el consumo de memoria es una de las tendencias que vemos en las nuevas versiones de C# (y .NET en general). Desde C# 7.0 se han introducido versiones &amp;ldquo;Value&amp;rdquo; de algunas APIs, como por ejemplo:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;Task&lt;/code&gt; y &lt;code&gt;ValueTask&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Tuple&lt;/code&gt; y &lt;code&gt;ValueTuple&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Estos nuevos tipos son de valor y no de referencia, como si representaran un significado especial para el programador.  Se explica que un tipo por referencia como &lt;code&gt;Tuple&lt;/code&gt;  se guarda en el Heap (Memoria), y un tipo por valor como &lt;code&gt;ValueTuple&lt;/code&gt; se guarda en el Call Stack, ¿Pero qué ventajas tiene el Stack sobre el Heap ?&lt;/p&gt;</description>
    </item>
    <item>
      <title>Proyectos</title>
      <link>/projects/</link>
      <pubDate>Sun, 22 Sep 2024 16:40:06 -0700</pubDate>
      <guid>/projects/</guid>
      <description>&lt;p&gt;Proyectos&lt;/p&gt;</description>
    </item>
    <item>
      <title>Links</title>
      <link>/links/</link>
      <pubDate>Sun, 22 Sep 2024 16:38:24 -0700</pubDate>
      <guid>/links/</guid>
      <description>&lt;p&gt;Links&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cómo Crear un Chatbot con C#, Unum USearch y OpenAI</title>
      <link>/blog/como-crear-chatbot-csharp-usearch-openai/</link>
      <pubDate>Sun, 22 Sep 2024 15:55:14 -0700</pubDate>
      <guid>/blog/como-crear-chatbot-csharp-usearch-openai/</guid>
      <description>&lt;h2 id=&#34;cómo-crear-un-chatbot-con-c-unum-usearch-y-openai&#34;&gt;Cómo Crear un Chatbot con C#, Unum USearch y OpenAI&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Este tutorial está basado en una transcripción de un video generada con el modelo whisper y ChatGPT o1-preview &lt;a href=&#34;https://www.youtube.com/watch?v=GGt_x7Lekp8&#34;&gt;Video Completo&lt;/a&gt;&#xA;&lt;a href=&#34;https://github.com/cosmez/ChatBotExample&#34;&gt;Codigo Completo&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;Una de las solicitudes más comunes de los clientes interesados en trabajar con inteligencia artificial es desarrollar un chatbot que pueda responder en lenguaje natural. En este artículo, exploraremos cómo implementar un chatbot utilizando las librerías proporcionadas por OpenAI y una pequeña base de datos vectorial llama USearch. Este enfoque no es el único, pero es una forma efectiva de abordar el problema.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Intro</title>
      <link>/posts/intro/</link>
      <pubDate>Sun, 22 Sep 2024 15:46:35 -0700</pubDate>
      <guid>/posts/intro/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;This is &lt;strong&gt;bold&lt;/strong&gt; text, and this is &lt;em&gt;emphasized&lt;/em&gt; text.&lt;/p&gt;&#xA;&lt;p&gt;Visit the &lt;a href=&#34;https://gohugo.io&#34;&gt;Hugo&lt;/a&gt; website!&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
